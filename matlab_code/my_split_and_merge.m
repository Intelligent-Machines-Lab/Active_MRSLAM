% Split and Merge on steroids
% Does all the post processing using some heuristics to eliminate bad lines
function new_list = my_split_and_merge(data, eps)
        debug = 0;

        % Split and merge algorithm
        list = split_and_merge(data, eps);
        
        % Post processing of list of segments generated by split_and_merge
        % Initial-same-as-last-point bug
        samePoint_th = 0.05;
        if norm(list(1, :) - list(end, :)) < samePoint_th
            list(1, :) = [];
            list(end, :) = list(1, :); % Get the new fist segment, not the empty one
        end
        % new_list will be {n,2}, each line is a segment and flag for
        % validness in the format {[x1, y1; x2, y2], [binary]}
        new_list = {};
        % Check for inliners on segments
        for l=1:size(list, 1)-1
            segment = list(l:l+1, :);
            inliners = check_points_inline(data, segment, debug);
            % If there are inliners, lift a flag on this segment
            if inliners
                new_list = cat(1, new_list, {double(segment), 1});
            else
                new_list = cat(1, new_list, {double(segment), 0});
            end
        end
        
%         idx = find([new_list{:, 2}]);
        idx = [new_list{:, 2}] == 1;
        new_list = new_list(idx, :);
        % Merging of common points that have segments with same slope
        % slope tolerance (5 degrees)
        mtol = pi/36;
%         mtol = pi/12; % 15 degrees
        ptol = 0.05;
%         ptol = 0.1;
        mergeHere = [];
        for l=1:size(new_list, 1)-1
            segment1 = new_list{l, 1};
            segment2 = new_list{l+1, 1};
            
            % Check if points are nearly common
            if (norm(segment1(2, :) - segment2(1, :)) < ptol) || (norm(segment1(1, :) - segment2(2, :)) < ptol)
                m1 = atan2((segment1(1, 2) - segment1(2, 2)), (segment1(1, 1) - segment1(2, 1)));
                m2 = atan2((segment2(1, 2) - segment2(2, 2)), (segment2(1, 1) - segment2(2, 1)));

                if abs(m1 - m2) < mtol
                    mergeHere = cat(2, mergeHere, l);
                else
                end
            end
        end
        % New, but changes stuff
        for m=mergeHere
            new_list{m, 1} = [new_list{m, 1}(1, :); new_list{m+1, 1}(2, :)];
        end
        new_list(mergeHere+1, :) = [];
        % Old, is buggy
%         for m=mergeHere
%             new_list{m, 1} = [new_list{m, 1}(1, :); new_list{m+1, 1}(2, :)];
%             new_list(m+1, :) = [];
%         end
        
        
%         figure;
%         subplot(121);
%         hold on;
%         for j=1:m
%             plot(new_list{j, 1}(:, 1), new_list{j, 1}(:, 2), 'o-');
%         end
%         hold off;
%         axis equal;
%         grid on;
%         n = size(new_list, 1);
%         title(['All Lines: ', num2str(n), '. Invalid Lines: ', num2str(n-length(idx))]);
%         subplot(122);
%         plot(data(:, 1), data(:, 2), 'r.');
%         axis equal;
%         grid on;
%         title({'Raw data'});
        
end
% Creates a square formed by the segment points and check for points
% inside, if there are, creates a distance threshold over the segment to
% check for points inside
function [ok, idxInliers] = check_points_inline(pts, segment, debug)
    xmin = min(segment(:, 1));
    xmax = max(segment(:, 1));
    ymin = min(segment(:, 2));
    ymax = max(segment(:, 2));
    
    % Some tolerance on limits for the square
    little = 0.01;
    isVertical = 0.02;
    isHorizontal = 0.02;
    
    if abs(xmin-xmax) < isVertical
        % If vertical segment
        xok = (pts(:, 1) < (xmax+little)) & (pts(:, 1) > (xmin-little));
        yok = (pts(:, 2) < ymax) & (pts(:, 2) > ymin);
    elseif abs(ymin-ymax) < isHorizontal
        % If horizontal segment
        xok = (pts(:, 1) < xmax) & (pts(:, 1) > xmin);
        yok = (pts(:, 2) < (ymax+little)) & (pts(:, 2) > (ymin-little));
    else
        % If diagonal segment
        xok = (pts(:, 1) < xmax) & (pts(:, 1) > xmin);
        yok = (pts(:, 2) < ymax) & (pts(:, 2) > ymin);
    end
    
    % idx will be the points inside the square formed by segment
    idx = (xok & yok);
    
    if nargout > 1
        idxInliers = idx;
    end
    
    % if idx is not empty, verify the threshold for inline
    n = find(idx);
    c = 0;
    j = [];
    % distance threshold over the segment
    dth = 0.05;
    % maximum allowed for number of inliers
    cmax = 5;
    if ~isempty(n)
        for i=n'
            d = point_to_line(pts(i, :), segment(1, :), segment(2, :));
            if d < dth
                j = cat(1, j, i);
                c = c + 1;
            end
        end
        % it will be ok if theres more than cmax inliers
%         disp(c)
        ok = (c > cmax);
    else
%         disp('Not verified');
        ok = 0;
    end
    
    if debug
        figure;
        hold on;
        plot(pts(:, 1), pts(:, 2), 'r.');
        if ~isempty(j)
            plot(pts(j, 1), pts(j, 2), 'bo');
        end
        plot(segment(:, 1), segment(:, 2), 'mx-');
        hold off;
        axis equal;
        grid on;
    end
    
end
